Goal / Current State Summary

We have a single Vite + TypeScript workspace that hosts multiple isolated frontend framework
implementations (React, Preact, Solid, Vue, Svelte, Remix, Vanilla, and Vani) side by side.

Current goals in practice:
- Keep framework implementations isolated by directory and tsconfig
- Use one root Vite config that builds all pages + all framework entries
- Keep TSX allowed globally, with JSX runtime behavior controlled per framework tsconfig
- Avoid per-framework Vite configs; keep build orchestration centralized

Vite setup (current):
- One root Vite config at bench/vite.config.ts
- Entry points are generated by bench/plugins/vite-plugin-multi-html.ts, which scans:
  - bench/src/pages/**/index.html -> mounted at /
  - bench/frameworks/*/index.html -> mounted under /frameworks
- The same plugin maps dev URLs to those HTML files and flattens build output so
  pages land in bench/dist/ without the src/pages prefix
- Build output is a single bench/dist/ folder (not per-framework output dirs)
- Framework-specific plugins are wired through bench/plugins/vite-plugin-multi-framework.ts:
  - Plugins are scoped by TSX suffix (e.g. .react.tsx, .solid.tsx)
  - A "no global JSX config" plugin prevents cross-framework JSX bleed

TypeScript architecture (current):
- Root bench/tsconfig.json is a solution config only:
  - References all per-framework tsconfigs + tsconfig.app.json
  - Includes only vite.config.ts in "files"
- All compiler options live under bench/tsconfigs/
- bench/tsconfigs/tsconfig.base.json contains shared options:
  - target/module/moduleResolution aligned with Vite
  - baseUrl and paths aliases (e.g. "@/bench/*")
  - does not define jsx; JSX mode is set per framework tsconfig
- Each framework has its own tsconfig (tsconfig.react.json, tsconfig.preact.json, etc.):
  - Extends tsconfig.base.json
  - Defines framework-specific JSX behavior (jsxImportSource where needed)
  - Uses include to scope files to that framework’s directory
- No per-extension tsconfigs; isolation is directory-based

Important TypeScript behavior to account for:
- compilerOptions are merged via extends:
  - Scalars override
  - Objects (like paths) merge shallowly
  - Arrays (types, lib, include, exclude) are replaced
- baseUrl and paths are resolved relative to the tsconfig file that defines them
  (not the root tsconfig, not the workspace root)

Editor vs compiler distinction:
- Project references define the compiler/build graph
- Editors (tsserver) discover projects by walking up the directory tree
- Referenced tsconfigs outside the directory ancestry may be ignored by the editor
- This can cause path aliases to appear unresolved in the editor even though tsc works

Optional resolution strategy (not applied yet):
- Keep the reference-based architecture (do NOT flatten configs)
- Optionally add lightweight “shim” tsconfig.json files inside framework folders
  that simply extend the real framework tsconfig, purely to help editor discovery
- Do not move compilerOptions into the root tsconfig
- Do not sacrifice framework isolation for editor convenience

Outcome:
- One centralized, framework-agnostic Vite + TS setup
- Isolation handled by tsconfig + directory layout
- Framework-specific Vite plugin scoping is active and controlled by file suffixes
